<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>No 2×2 Monochrome Grid Demo</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      text-align: center;
      margin: 2rem;
    }
    canvas {
      border: 1px solid #444;
      aspect-ratio: 1 / 1; /* keep the canvas square */
      max-width: 90vmin;
      height: auto;
    }
    #controls {
      margin-top: 1rem;
      display: flex;
      justify-content: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    input, button {
      padding: 0.3rem 0.6rem;
      font-size: 1rem;
      border-radius: 0.5rem;
      border: 1px solid #777;
    }
    button {
      cursor: pointer;
      background: #f5f5f5;
      transition: background 0.2s;
    }
    button:hover { background: #e0e0e0; }
  </style>
</head>
<body>
  <h1>No 2×2 Monochrome Grid Demo</h1>
  <canvas id="grid" width="400" height="400"></canvas>

  <div id="controls">
    <label>Grid size (n × n):
      <input type="number" id="size" value="20" min="4" max="200" step="1">
    </label>
    <button id="generate">Generate</button>
  </div>

  <script>
    /** Greedy fill that avoids monochrome 2×2 blocks. */
    function generateGrid(rows, cols) {
      const g = Array.from({ length: rows }, () => Array(cols).fill(0));
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          let forbidden = null;

          // Check the 2×2 block we would complete: NW, N, W, X
          if (
            r > 0 && c > 0 &&
            g[r - 1][c - 1] === g[r - 1][c] &&
            g[r - 1][c] === g[r][c - 1]
          ) {
            forbidden = g[r - 1][c - 1];
          }

          // Choose a colour that is not forbidden (0 = white, 1 = black)
          const choices = forbidden === null ? [0, 1] : [1 - forbidden];
          g[r][c] = choices[Math.floor(Math.random() * choices.length)];
        }
      }
      return g;
    }

    /** Draw the binary grid on the <canvas>. */
    function drawGrid(grid) {
      const canvas = document.getElementById("grid");
      const ctx = canvas.getContext("2d");
      const rows = grid.length;
      const cols = grid[0].length;
      const cellSize = Math.floor(Math.min(canvas.width / cols, canvas.height / rows));

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          ctx.fillStyle = grid[r][c] ? "#000" : "#fff";
          ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);
        }
      }
    }

    /** Generate a new grid using the current size input. */
    function run() {
      const s = parseInt(document.getElementById("size").value, 10);
      const grid = generateGrid(s, s);
      drawGrid(grid);
    }

    document.getElementById("generate").addEventListener("click", run);
    window.addEventListener("load", run); // initial draw on page load
  </script>
</body>
</html>
