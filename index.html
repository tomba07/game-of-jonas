<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>No 2×2 Monochrome or Checkerboard Grid — Reduced “Stairs”</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, sans-serif; text-align: center; margin: 2rem; }
    canvas {
      border: 1px solid #444;
      aspect-ratio: 1 / 1;
      max-width: 90vmin;
      height: auto;
    }
    #controls { margin-top: 1rem; display: flex; justify-content: center; gap: 0.5rem; flex-wrap: wrap; }
    input, button { padding: 0.3rem 0.6rem; font-size: 1rem; border-radius: 0.5rem; border: 1px solid #777; }
    button { cursor: pointer; background: #f5f5f5; transition: background 0.2s; }
    button:hover { background: #e0e0e0; }
    #legend { display: flex; flex-wrap: wrap; justify-content: center; gap: 0.3rem; margin-top: 1rem; }
    .swatch { width: 1.2rem; height: 1.2rem; border: 1px solid #333; border-radius: 0.2rem; }
  </style>
</head>
<body>
  <h1>No 2×2 Monochrome <em>or</em> Checkerboard Grid</h1>
  <canvas id="grid" width="400" height="400"></canvas>

  <div id="controls">
    <label>Grid size (n × n):
      <input type="number" id="size" value="20" min="4" max="200" step="1" />
    </label>
    <label>Colours:
      <input type="number" id="colors" value="2" min="2" max="20" step="1" />
    </label>
    <button id="generate">Generate</button>
  </div>

  <div id="legend"></div>

  <script>
    /*──────────────── helper: palette ────────────────*/
    function indexToColour(i, k) {
      if (k === 2) return i === 0 ? "#fff" : "#000";
      return `hsl(${(i * 360) / k} 70% 50%)`;
    }

    /*──────────────── 2×2 filter ────────────────────*/
    function isForbidden(nw, n, w, x) {
      if (nw === n && n === w && w === x) return true;                 // monochrome
      if (nw === x && n === w && nw !== n) return true;                // checker A
      if (nw === w && n === x && nw !== n) return true;                // checker B
      return false;
    }

    /*──────────────── grid generator ────────────────*/
    function generateGrid(rows, cols, k) {
      const g = Array.from({ length: rows }, () => Array(cols));

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          // 1. Collect legal colours
          const legal = [];
          for (let colour = 0; colour < k; colour++) {
            if (r === 0 || c === 0) {                      // first row/col: any colour is legal
              legal.push(colour);
            } else {
              const nw = g[r - 1][c - 1];
              const n  = g[r - 1][c];
              const w  = g[r][c - 1];
              if (!isForbidden(nw, n, w, colour)) legal.push(colour);
            }
          }

          // 2. If we are on first row *or* first column, pick uniformly at random
          if (r === 0 || c === 0) {
            g[r][c] = legal[Math.floor(Math.random() * legal.length)];
            continue;
          }

          // 3. Otherwise apply anti‑stair heuristic
          let best = legal[0];
          let bestScore = Infinity;
          for (const colour of legal) {
            let score = 0;

            // favour straight continuation
            if (colour !== g[r - 1][c]) score += 1; // vertical mismatch penalty
            if (colour !== g[r][c - 1]) score += 1; // horizontal mismatch penalty

            // avoid 2×2 "stair" (diagonal step) motif
            const nw = g[r - 1][c - 1];
            const n  = g[r - 1][c];
            const w  = g[r][c - 1];
            const step1 = nw === colour && n !== colour && w !== colour;
            const step2 = nw !== colour && n === colour && w === colour;
            if (step1 || step2) score += 2;

            if (score < bestScore || (score === bestScore && Math.random() < 0.5)) {
              bestScore = score;
              best = colour;
            }
          }
          g[r][c] = best;
        }
      }
      return g;
    }

    /*──────────────── canvas draw ───────────────────*/
    function drawGrid(grid, k) {
      const canvas = document.getElementById("grid");
      const ctx = canvas.getContext("2d");
      const rows = grid.length;
      const cols = grid[0].length;
      const cell = Math.floor(Math.min(canvas.width / cols, canvas.height / rows));

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          ctx.fillStyle = indexToColour(grid[r][c], k);
          ctx.fillRect(c * cell, r * cell, cell, cell);
        }
      }
    }

    /*──────────────── legend ───────────────────────*/
    function drawLegend(k) {
      const legend = document.getElementById("legend");
      legend.innerHTML = "";
      for (let i = 0; i < k; i++) {
        const sw = document.createElement("div");
        sw.className = "swatch";
        sw.style.background = indexToColour(i, k);
        legend.appendChild(sw);
      }
    }

    /*──────────────── main hook ────────────────────*/
    function run() {
      const size = Math.max(4, +document.getElementById("size").value || 20);
      const k    = Math.max(2, +document.getElementById("colors").value || 2);
      const grid = generateGrid(size, size, k);
      drawGrid(grid, k);
      drawLegend(k);
    }

    document.getElementById("generate").addEventListener("click", run);
    window.addEventListener("load", run);
  </script>
</body>
</html>
