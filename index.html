<!DOCTYPE html>
<html>
  <head>
    <title>Wave Function Collapse Simulation</title>
    <style>
      .grid-container {
        display: grid;
        grid-template-columns: repeat(15, 10px);
      }
      .grid-item {
        width: 10px;
        height: 10px;
        background-color: white;
      }
      .black {
        background-color: black;
      }
      .uncollapsed {
        background-color: lightgrey;
      }
    </style>
  </head>
  <bodColumn>
    <button id="playButton">Play</button>
    <button id="stopButton">Stop</button>
    <button id="resetButton">Reset</button>

    <div class="grid-container" id="gridContainer"></div>

    <script>
      const gridContainer = document.getElementById("gridContainer");
      const gridSize = 15;
      const states = ["black", "white"];
      const maxAttempts = gridSize * gridSize;
      let decisionStack = []; // Global decision stack
      let currentIndex = -1; // Points to the current decision
      let lastCollapsedCell = null;
      let isSimulationRunning = false;

      window.grid = Array.from({ length: gridSize }, () => Array(gridSize).fill([...states]));
      window.attempts = 0;

      document.getElementById("playButton").addEventListener("click", function () {
        isSimulationRunning = true;
        performWaveFunctionCollapseStep();
        updateUI();
      });
      document.getElementById("stopButton").addEventListener("click", function () {
        isSimulationRunning = false;
        updateUI();
      });
      document.getElementById("resetButton").addEventListener("click", function () {
        resetGrid();
        isSimulationRunning = false;
        updateUI();
        displayGrid();
      });

      //render initial grid
      displayGrid();

      function updateUI() {
        document.getElementById("playButton").disabled = isSimulationRunning;
        document.getElementById("stopButton").disabled = !isSimulationRunning;
      }

      function resetGrid() {
        window.grid = Array.from({ length: gridSize }, () => Array(gridSize).fill([...states]));
        window.attempts = 0;
        lastCollapsedCell = null;
      }

      function displayGrid() {
        gridContainer.innerHTML = "";
        window.grid.forEach((row, rowIndex) => {
          row.forEach((cellState, columnIndex) => {
            const cell = document.createElement("div");
            cell.className = "grid-item";
            if (cellState.length === 1) {
              cell.classList.add(cellState[0]);
            } else {
              cell.classList.add("uncollapsed");
            }
            gridContainer.appendChild(cell);
          });
        });
      }

      function selectCellToCollapse() {
        let potentialCells = [];

        if (lastCollapsedCell) {
          const neighbors = getNeighbors(lastCollapsedCell.row, lastCollapsedCell.column, gridSize);
          potentialCells = neighbors.filter((neighbor) => window.grid[neighbor.row][neighbor.column].length > 1);
        }

        if (potentialCells.length === 0) {
          // No available neighbors, fallback to selecting from any uncollapsed cells
          for (let row = 0; row < gridSize; row++) {
            for (let column = 0; column < gridSize; column++) {
              if (window.grid[row][column].length > 1) {
                potentialCells.push({ row, column });
              }
            }
          }
        }

        if (potentialCells.length > 0) {
          const randomIndex = Math.floor(Math.random() * potentialCells.length);
          return potentialCells[randomIndex];
        }

        return null;
      }

      function collapseCell(cell) {
        let { row, column } = cell;
        let cellStates = window.grid[row][column];
        let collapsedState = null;

        if (cellStates.length > 1) {
          collapsedState = cellStates[Math.floor(Math.random() * cellStates.length)];
          window.grid[row][column] = [collapsedState];
          lastCollapsedCell = { row, column }; // Update lastCollapsedCell
          decisionStack.push([{ row, column }]);
        }

        return collapsedState;
      }

      function propagateConstraints() {
        const breakingFields = new Set();
        let changesMade = false;
        do {
          changesMade = false;
          for (let row = 0; row < gridSize; row++) {
            for (let column = 0; column < gridSize; column++) {
              if (window.grid[row][column].length > 1) {
                let newStates = window.grid[row][column].filter((state) => isValidState(row, column, state));

                if (newStates.length !== window.grid[row][column].length) {
                  window.grid[row][column] = newStates;
                  lastCollapsedCell = { row, column }; // Update lastCollapsedCell
                  decisionStack[decisionStack.length - 1].push({ row, column }); //these decisions are consequences of the last collapsed cell. Have to be reverted together
                  changesMade = true;
                }

                if (newStates.length === 0) {
                  //   if (breakingFields.has(`${row}:${column}`)) {
                  //     //maybe resetting is too aggressive. Maybe just backtrack more...
                  //     resetGrid();
                  //   } else {
                  //     breakingFields.add(`${row}:${column}`);
                  //   }

                  backTrackUntilFixed();
                  return;
                }
              }
            }
          }
        } while (changesMade);
      }

      function backTrackUntilFixed() {
        while (gridBreaksRules()) {
          backTrackDecision();
        }
      }

      function isValidState(row, column, state) {
        const gridSize = window.grid.length;
        window.grid[row][column] = [state];

        // Check all 2x2 grids including the cell (row, column)
        for (let dRow = -1; dRow <= 0; dRow++) {
          for (let dColumn = -1; dColumn <= 0; dColumn++) {
            if (!is2x2Valid(dRow + row, dColumn + column)) {
              window.grid[row][column] = states;
              return false;
            }
          }
        }
        window.grid[row][column] = states;
        return true;
      }

      function is2x2Valid(topLeftRow, topLeftColumn) {
        const gridSize = window.grid.length;
        let result = true;

        if (!(topLeftRow < 0 || topLeftColumn < 0 || topLeftRow >= gridSize - 1 || topLeftColumn >= gridSize - 1)) {
          const cell1 = window.grid[topLeftRow][topLeftColumn];
          const cell2 = window.grid[topLeftRow + 1][topLeftColumn];
          const cell3 = window.grid[topLeftRow][topLeftColumn + 1];
          const cell4 = window.grid[topLeftRow + 1][topLeftColumn + 1];
          const allCollapsed = cell1.length === 1 && cell2.length === 1 && cell3.length === 1 && cell4.length === 1;

          if (allCollapsed) {
            const color1 = cell1[0];
            const color2 = cell2[0];
            const color3 = cell3[0];
            const color4 = cell4[0];
            const allColorsSame = color1 === color2 && color2 === color3 && color3 === color4;
            const checkeredPattern = color1 === color4 && color2 === color3 && color1 !== color2;

            result = !allColorsSame && !checkeredPattern;
          }
        }

        return result;
      }

      function getNeighbors(row, column, gridSize) {
        let neighbors = [];
        for (let dRow = -1; dRow <= 1; dRow++) {
          for (let dColumn = -1; dColumn <= 1; dColumn++) {
            if (dRow === 0 && dColumn === 0) continue; // Skip the cell itself
            let nRow = row + dRow;
            let nColumn = column + dColumn;
            if (nRow >= 0 && nRow < gridSize && nColumn >= 0 && nColumn < gridSize) {
              neighbors.push({ row: nRow, column: nColumn });
            }
          }
        }
        return neighbors;
      }

      function isGridFullyCollapsed() {
        return window.grid.every((row) => row.every((cell) => cell.length === 1));
      }

      function backTrackDecision() {
        const lastDecision = decisionStack.pop();

        if (!lastDecision) {
          // If there are no previous decisions, reset the grid and index
          window.grid = Array.from({ length: gridSize }, () => Array(gridSize).fill([...states]));
          lastCollapsedCell = null;
          return;
        } else {
          lastDecision.forEach((decisionConsequence) => {
            const { row, column } = decisionConsequence;
            window.grid[row][column] = states;
            lastCollapsedCell = { ...decisionStack[decisionStack.length - 1][0] };
          });
        }
      }

      function gridBreaksRules() {
        let result = false;
        window.grid.forEach((row, rowIndex) => {
          row.forEach((cell, columnIndex) => {
            if (cell.length === 0) {
              result = true;
            }
          });
        });

        return result;
      }

      function performWaveFunctionCollapseStep() {
        if (!isSimulationRunning) {
          updateUI();
          return;
        }

        window.attempts++;
        if (window.attempts > maxAttempts) {
          resetGrid();
        }

        // Perform a single step of the simulation
        const cell = selectCellToCollapse();
        if (cell) {
          collapseCell(cell);
          propagateConstraints();
          currentIndex++;
        }

        displayGrid();

        if (!isGridFullyCollapsed()) {
          requestAnimationFrame(performWaveFunctionCollapseStep); // Schedule the next step
        } else {
          document.getElementById("stopButton").disabled = true;
        }
      }
    </script>
  </bodColumn>
</html>
