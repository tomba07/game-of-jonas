<!DOCTYPE html>
<html>
  <head>
    <title>Wave Function Collapse Simulation</title>
    <style>
      .grid-container {
        display: grid;
        grid-template-columns: repeat(10, 10px);
      }
      .grid-item {
        width: 10px;
        height: 10px;
        background-color: white;
      }
      .black {
        background-color: black;
      }
      .uncollapsed {
        background-color: lightgrey;
      }
    </style>
  </head>
  <bodColumn>
    <p id="actionText">Press the button to start collapsing cells.</p>
    <button id="collapseButton">Collapse Next Cell</button>
    <button id="playButton">Play</button>
    <div class="grid-container" id="gridContainer"></div>

    <script>
      const gridContainer = document.getElementById("gridContainer");

      // Grid dimensions
      const gridSize = 10;
      const maxRetries = 30;

      // Possible states
      const states = ["black", "white"];
      // Initialize grid
      let grid = Array.from({ length: gridSize }, () => Array(gridSize).fill([...states]));
      let intervalId = null; // Variable to store the interval ID

      document.getElementById("collapseButton").addEventListener("click", performWaveFunctionCollapseStep);
      document.getElementById("playButton").addEventListener("click", function () {
        if (intervalId === null) {
          // Start automatic stepping
          this.textContent = "Pause"; // Change button text to 'Pause'
          intervalId = setInterval(function () {
            if (!isGridFullyCollapsed(grid)) {
              performWaveFunctionCollapseStep();
            } else {
              clearInterval(intervalId); // Stop the interval when done
              intervalId = null;
              document.getElementById("playButton").textContent = "Play"; // Change button text back to 'Play'
            }
          }, 1); // Execute a step every 0.5 seconds
        } else {
          // Stop automatic stepping
          clearInterval(intervalId);
          intervalId = null;
          this.textContent = "Play"; // Change button text back to 'Play'
        }
      });

      //render initial grid
      displayGrid(grid);

      // Function to display the grid
      function displayGrid(grid) {
        // Clear existing grid
        gridContainer.innerHTML = "";
        // Create and display cells
        grid.forEach((row, rowIndex) => {
          row.forEach((cellState, columnIndex) => {
            const cell = document.createElement("div");
            cell.className = "grid-item";
            if (cellState.length === 1) {
              cell.classList.add(cellState[0]);
            } else {
              // Add 'uncollapsed' class for cells in superposition
              cell.classList.add("uncollapsed");
            }
            // Add click event listener to log the possible states of the cell
            cell.addEventListener("click", () => {
              console.log(`Possible states for cell (${rowIndex}, ${columnIndex}): `, grid[rowIndex][columnIndex]);
            });
            gridContainer.appendChild(cell);
          });
        });
      }

      function selectCellToCollapse(grid) {
        let pendingCells = [];

        for (let row = 0; row < gridSize; row++) {
          for (let column = 0; column < gridSize; column++) {
            const options = grid[row][column];

            if (options.length > 1) {
              pendingCells.push({ row, column });
            }
          }
        }

        if (pendingCells.length > 0) {
          const randomIndex = Math.floor(Math.random() * pendingCells.length);
          return pendingCells[randomIndex];
        }

        return null;
      }

      function collapseCell(grid, cell) {
        let { row, column } = cell;
        let cellStates = grid[row][column];
        if (cellStates.length > 1) {
          let collapsedState = cellStates[Math.floor(Math.random() * cellStates.length)];
          grid[row][column] = [collapsedState];
        }
      }

      function propagateConstraints(grid, row, column) {
        let toProcess = [{ row, column }];

        while (toProcess.length > 0) {
          let { row, column } = toProcess.shift();
          let neighbors = getNeighbors(row, column, gridSize);
          let collapsedState = grid[row][column][0];

          console.log(`propagating constraints for ${row}:${column} which is now ${grid[row][column][0]}`);

          neighbors.forEach((neighbor) => {
            let { row: nRow, column: nColumn } = neighbor;
            let neighborStates = grid[nRow][nColumn];

            if (neighborStates.length > 1) {
              let newStates = neighborStates.filter((state) => isValidState(nRow, nColumn, state, grid));

              if (newStates.length === 1) {
                grid[nRow][nColumn] = newStates;
                toProcess.push({row: nRow, column: nColumn});
                console.log(`neighbor at ${nRow}:${nColumn} now has collapsed to: ${neighborStates[0]}`)
                
              } else if (newStates.length === 0) {
                console.log(`neighbor at ${nRow}:${nColumn} now has an issue!`)
              }
            }else {
            }
          });
        }
      }

      function isValidState(row, column, state, grid) {
        const gridCopy = copyGrid(grid);
        const gridSize = grid.length;
        gridCopy[row][column] = [state];

        // Check all 2x2 grids including the cell (row, column)
        for (let dRow = -1; dRow <= 0; dRow++) {
          for (let dColumn = -1; dColumn <= 0; dColumn++) {
            if (!is2x2Valid(dRow + row, dColumn + column, gridCopy)) {
              return false;
            }
          }
        }
        return true;
      }

      function is2x2Valid(topLeftRow, topLeftColumn, gridCopy) {
        const gridSize = gridCopy.length;
        let result = true;

        if (!(topLeftRow < 0 || topLeftColumn < 0 || topLeftRow >= gridSize - 1 || topLeftColumn >= gridSize - 1)) {
          const cell1 = gridCopy[topLeftRow][topLeftColumn];
          const cell2 = gridCopy[topLeftRow + 1][topLeftColumn];
          const cell3 = gridCopy[topLeftRow][topLeftColumn + 1];
          const cell4 = gridCopy[topLeftRow + 1][topLeftColumn + 1];
          const allCollapsed = cell1.length === 1 && cell2.length === 1 && cell3.length === 1 && cell4.length === 1;

          if (allCollapsed) {
            const color1 = cell1[0];
            const color2 = cell2[0];
            const color3 = cell3[0];
            const color4 = cell4[0];
            const allColorsSame = color1 === color2 && color2 === color3 && color3 === color4;
            const checkeredPattern = color1 === color4 && color2 === color3 && color1 !== color2;

            result = !allColorsSame && !checkeredPattern;
          }
        }

        return result;
      }

      function getNeighbors(row, column, gridSize) {
        let neighbors = [];
        for (let dRow = -1; dRow <= 1; dRow++) {
          for (let dColumn = -1; dColumn <= 1; dColumn++) {
            if (dRow === 0 && dColumn === 0) continue; // Skip the cell itself
            let nRow = row + dRow;
            let nColumn = column + dColumn;
            if (nRow >= 0 && nRow < gridSize && nColumn >= 0 && nColumn < gridSize) {
              neighbors.push({ row: nRow, column: nColumn });
            }
          }
        }
        return neighbors;
      }

      function isGridFullyCollapsed(grid) {
        return grid.every((row) => row.every((cell) => cell.length === 1));
      }

      function detectContradiction(grid) {
        for (let row = 0; row < gridSize; row++) {
          for (let column = 0; column < gridSize; column++) {
            if (grid[row][column].length === 0) {
              return true; // Found a contradiction
            }
          }
        }
        return false; // No contradiction found
      }

      function copyGrid(grid) {
        return grid.map((row) => row.map((cell) => [...cell]));
      }

      let decisionStack = []; // Global decision stack
      let actionText = ""; // Text describing the last action

      function performWaveFunctionCollapseStep() {
        let action = "";

        if (!isGridFullyCollapsed(grid)) {
          if (detectContradiction(grid)) {
            let lastDecision = decisionStack[decisionStack.length - 1];
            action = `Backtracking at cell (${lastDecision.x}, ${lastDecision.y}), Retry count: ${lastDecision.retryCount}`;
            decisionStack.pop();
            if (decisionStack.length > 0) {
              grid = decisionStack[decisionStack.length - 1].gridSnapshot;
            } else {
              action = "No more moves to backtrack. Grid is stuck.";
            }
          } else {
            let cell = selectCellToCollapse(grid);
            if (cell) {
              collapseCell(grid, cell); // Using the updated function
              propagateConstraints(grid, cell.row, cell.column);
              decisionStack.push({
                gridSnapshot: copyGrid(grid) // Snapshot of the grid at this decision
              });
              action = "Collapsed cell at (" + cell.row + ", " + cell.column + ")";
            }
          }
        } else {
          action = "Grid fully collapsed!";
        }

        displayGrid(grid); // Update the grid display after each step
        updateActionText(action); // Update the action text
      }

      function updateActionText(text) {
        actionText = text;
        document.getElementById("actionText").innerText = actionText;
      }
    </script>
  </bodColumn>
</html>
